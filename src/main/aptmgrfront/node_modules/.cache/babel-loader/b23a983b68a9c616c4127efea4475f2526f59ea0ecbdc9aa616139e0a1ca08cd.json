{"ast":null,"code":"import { appearStoreId } from './store-id.mjs';\nimport { animateStyle } from '../animators/waapi/index.mjs';\nimport { optimizedAppearDataId } from './data-id.mjs';\nimport { handoffOptimizedAppearAnimation } from './handoff.mjs';\nimport { appearAnimationStore, elementsWithAppearAnimations } from './store.mjs';\nimport { noop } from '../../utils/noop.mjs';\nimport { getOptimisedAppearId } from './get-appear-id.mjs';\n\n/**\r\n * A single time to use across all animations to manually set startTime\r\n * and ensure they're all in sync.\r\n */\nlet startFrameTime;\n/**\r\n * A dummy animation to detect when Chrome is ready to start\r\n * painting the page and hold off from triggering the real animation\r\n * until then. We only need one animation to detect paint ready.\r\n *\r\n * https://bugs.chromium.org/p/chromium/issues/detail?id=1406850\r\n */\nlet readyAnimation;\n/**\r\n * Keep track of animations that were suspended vs cancelled so we\r\n * can easily resume them when we're done measuring layout.\r\n */\nconst suspendedAnimations = new Set();\nfunction resumeSuspendedAnimations() {\n  suspendedAnimations.forEach(data => {\n    data.animation.play();\n    data.animation.startTime = data.startTime;\n  });\n  suspendedAnimations.clear();\n}\nfunction startOptimizedAppearAnimation(element, name, keyframes, options, onReady) {\n  // Prevent optimised appear animations if Motion has already started animating.\n  if (window.MotionHandoffIsComplete) {\n    window.MotionHandoffAnimation = undefined;\n    return;\n  }\n  const id = element.dataset[optimizedAppearDataId];\n  if (!id) return;\n  window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;\n  const storeId = appearStoreId(id, name);\n  if (!readyAnimation) {\n    readyAnimation = animateStyle(element, name, [keyframes[0], keyframes[0]],\n    /**\r\n     * 10 secs is basically just a super-safe duration to give Chrome\r\n     * long enough to get the animation ready.\r\n     */\n    {\n      duration: 10000,\n      ease: \"linear\"\n    });\n    appearAnimationStore.set(storeId, {\n      animation: readyAnimation,\n      startTime: null\n    });\n    /**\r\n     * If there's no readyAnimation then there's been no instantiation\r\n     * of handoff animations.\r\n     */\n    window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;\n    window.MotionHasOptimisedAnimation = (elementId, valueName) => {\n      if (!elementId) return false;\n      /**\r\n       * Keep a map of elementIds that have started animating. We check\r\n       * via ID instead of Element because of hydration errors and\r\n       * pre-hydration checks. We also actively record IDs as they start\r\n       * animating rather than simply checking for data-appear-id as\r\n       * this attrbute might be present but not lead to an animation, for\r\n       * instance if the element's appear animation is on a different\r\n       * breakpoint.\r\n       */\n      if (!valueName) {\n        return elementsWithAppearAnimations.has(elementId);\n      }\n      const animationId = appearStoreId(elementId, valueName);\n      return Boolean(appearAnimationStore.get(animationId));\n    };\n    /**\r\n     * We only need to cancel transform animations as\r\n     * they're the ones that will interfere with the\r\n     * layout animation measurements.\r\n     */\n    window.MotionCancelOptimisedAnimation = (elementId, valueName, frame, canResume) => {\n      const animationId = appearStoreId(elementId, valueName);\n      const data = appearAnimationStore.get(animationId);\n      if (!data) return;\n      if (frame && canResume === undefined) {\n        /**\r\n         * Wait until the end of the subsequent frame to cancel the animation\r\n         * to ensure we don't remove the animation before the main thread has\r\n         * had a chance to resolve keyframes and render.\r\n         */\n        frame.postRender(() => {\n          frame.postRender(() => {\n            data.animation.cancel();\n          });\n        });\n      } else {\n        data.animation.cancel();\n      }\n      if (frame && canResume) {\n        suspendedAnimations.add(data);\n        frame.render(resumeSuspendedAnimations);\n      } else {\n        appearAnimationStore.delete(animationId);\n        /**\r\n         * If there are no more animations left, we can remove the cancel function.\r\n         * This will let us know when we can stop checking for conflicting layout animations.\r\n         */\n        if (!appearAnimationStore.size) {\n          window.MotionCancelOptimisedAnimation = undefined;\n        }\n      }\n    };\n    window.MotionCheckAppearSync = (visualElement, valueName, value) => {\n      var _a, _b;\n      const appearId = getOptimisedAppearId(visualElement);\n      if (!appearId) return;\n      const valueIsOptimised = (_a = window.MotionHasOptimisedAnimation) === null || _a === void 0 ? void 0 : _a.call(window, appearId, valueName);\n      const externalAnimationValue = (_b = visualElement.props.values) === null || _b === void 0 ? void 0 : _b[valueName];\n      if (!valueIsOptimised || !externalAnimationValue) return;\n      const removeSyncCheck = value.on(\"change\", latestValue => {\n        var _a;\n        if (externalAnimationValue.get() !== latestValue) {\n          (_a = window.MotionCancelOptimisedAnimation) === null || _a === void 0 ? void 0 : _a.call(window, appearId, valueName);\n          removeSyncCheck();\n        }\n      });\n      return removeSyncCheck;\n    };\n  }\n  const startAnimation = () => {\n    readyAnimation.cancel();\n    const appearAnimation = animateStyle(element, name, keyframes, options);\n    /**\r\n     * Record the time of the first started animation. We call performance.now() once\r\n     * here and once in handoff to ensure we're getting\r\n     * close to a frame-locked time. This keeps all animations in sync.\r\n     */\n    if (startFrameTime === undefined) {\n      startFrameTime = performance.now();\n    }\n    appearAnimation.startTime = startFrameTime;\n    appearAnimationStore.set(storeId, {\n      animation: appearAnimation,\n      startTime: startFrameTime\n    });\n    if (onReady) onReady(appearAnimation);\n  };\n  elementsWithAppearAnimations.add(id);\n  if (readyAnimation.ready) {\n    readyAnimation.ready.then(startAnimation).catch(noop);\n  } else {\n    startAnimation();\n  }\n}\nexport { startOptimizedAppearAnimation };","map":{"version":3,"names":["appearStoreId","animateStyle","optimizedAppearDataId","handoffOptimizedAppearAnimation","appearAnimationStore","elementsWithAppearAnimations","noop","getOptimisedAppearId","startFrameTime","readyAnimation","suspendedAnimations","Set","resumeSuspendedAnimations","forEach","data","animation","play","startTime","clear","startOptimizedAppearAnimation","element","name","keyframes","options","onReady","window","MotionHandoffIsComplete","MotionHandoffAnimation","undefined","id","dataset","storeId","duration","ease","set","MotionHasOptimisedAnimation","elementId","valueName","has","animationId","Boolean","get","MotionCancelOptimisedAnimation","frame","canResume","postRender","cancel","add","render","delete","size","MotionCheckAppearSync","visualElement","value","_a","_b","appearId","valueIsOptimised","call","externalAnimationValue","props","values","removeSyncCheck","on","latestValue","startAnimation","appearAnimation","performance","now","ready","then","catch"],"sources":["D:/dev/code/java/aptMgrSpringReact/src/main/aptmgrfront/node_modules/framer-motion/dist/es/animation/optimized-appear/start.mjs"],"sourcesContent":["import { appearStoreId } from './store-id.mjs';\r\nimport { animateStyle } from '../animators/waapi/index.mjs';\r\nimport { optimizedAppearDataId } from './data-id.mjs';\r\nimport { handoffOptimizedAppearAnimation } from './handoff.mjs';\r\nimport { appearAnimationStore, elementsWithAppearAnimations } from './store.mjs';\r\nimport { noop } from '../../utils/noop.mjs';\r\nimport { getOptimisedAppearId } from './get-appear-id.mjs';\r\n\r\n/**\r\n * A single time to use across all animations to manually set startTime\r\n * and ensure they're all in sync.\r\n */\r\nlet startFrameTime;\r\n/**\r\n * A dummy animation to detect when Chrome is ready to start\r\n * painting the page and hold off from triggering the real animation\r\n * until then. We only need one animation to detect paint ready.\r\n *\r\n * https://bugs.chromium.org/p/chromium/issues/detail?id=1406850\r\n */\r\nlet readyAnimation;\r\n/**\r\n * Keep track of animations that were suspended vs cancelled so we\r\n * can easily resume them when we're done measuring layout.\r\n */\r\nconst suspendedAnimations = new Set();\r\nfunction resumeSuspendedAnimations() {\r\n    suspendedAnimations.forEach((data) => {\r\n        data.animation.play();\r\n        data.animation.startTime = data.startTime;\r\n    });\r\n    suspendedAnimations.clear();\r\n}\r\nfunction startOptimizedAppearAnimation(element, name, keyframes, options, onReady) {\r\n    // Prevent optimised appear animations if Motion has already started animating.\r\n    if (window.MotionHandoffIsComplete) {\r\n        window.MotionHandoffAnimation = undefined;\r\n        return;\r\n    }\r\n    const id = element.dataset[optimizedAppearDataId];\r\n    if (!id)\r\n        return;\r\n    window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;\r\n    const storeId = appearStoreId(id, name);\r\n    if (!readyAnimation) {\r\n        readyAnimation = animateStyle(element, name, [keyframes[0], keyframes[0]], \r\n        /**\r\n         * 10 secs is basically just a super-safe duration to give Chrome\r\n         * long enough to get the animation ready.\r\n         */\r\n        { duration: 10000, ease: \"linear\" });\r\n        appearAnimationStore.set(storeId, {\r\n            animation: readyAnimation,\r\n            startTime: null,\r\n        });\r\n        /**\r\n         * If there's no readyAnimation then there's been no instantiation\r\n         * of handoff animations.\r\n         */\r\n        window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;\r\n        window.MotionHasOptimisedAnimation = (elementId, valueName) => {\r\n            if (!elementId)\r\n                return false;\r\n            /**\r\n             * Keep a map of elementIds that have started animating. We check\r\n             * via ID instead of Element because of hydration errors and\r\n             * pre-hydration checks. We also actively record IDs as they start\r\n             * animating rather than simply checking for data-appear-id as\r\n             * this attrbute might be present but not lead to an animation, for\r\n             * instance if the element's appear animation is on a different\r\n             * breakpoint.\r\n             */\r\n            if (!valueName) {\r\n                return elementsWithAppearAnimations.has(elementId);\r\n            }\r\n            const animationId = appearStoreId(elementId, valueName);\r\n            return Boolean(appearAnimationStore.get(animationId));\r\n        };\r\n        /**\r\n         * We only need to cancel transform animations as\r\n         * they're the ones that will interfere with the\r\n         * layout animation measurements.\r\n         */\r\n        window.MotionCancelOptimisedAnimation = (elementId, valueName, frame, canResume) => {\r\n            const animationId = appearStoreId(elementId, valueName);\r\n            const data = appearAnimationStore.get(animationId);\r\n            if (!data)\r\n                return;\r\n            if (frame && canResume === undefined) {\r\n                /**\r\n                 * Wait until the end of the subsequent frame to cancel the animation\r\n                 * to ensure we don't remove the animation before the main thread has\r\n                 * had a chance to resolve keyframes and render.\r\n                 */\r\n                frame.postRender(() => {\r\n                    frame.postRender(() => {\r\n                        data.animation.cancel();\r\n                    });\r\n                });\r\n            }\r\n            else {\r\n                data.animation.cancel();\r\n            }\r\n            if (frame && canResume) {\r\n                suspendedAnimations.add(data);\r\n                frame.render(resumeSuspendedAnimations);\r\n            }\r\n            else {\r\n                appearAnimationStore.delete(animationId);\r\n                /**\r\n                 * If there are no more animations left, we can remove the cancel function.\r\n                 * This will let us know when we can stop checking for conflicting layout animations.\r\n                 */\r\n                if (!appearAnimationStore.size) {\r\n                    window.MotionCancelOptimisedAnimation = undefined;\r\n                }\r\n            }\r\n        };\r\n        window.MotionCheckAppearSync = (visualElement, valueName, value) => {\r\n            var _a, _b;\r\n            const appearId = getOptimisedAppearId(visualElement);\r\n            if (!appearId)\r\n                return;\r\n            const valueIsOptimised = (_a = window.MotionHasOptimisedAnimation) === null || _a === void 0 ? void 0 : _a.call(window, appearId, valueName);\r\n            const externalAnimationValue = (_b = visualElement.props.values) === null || _b === void 0 ? void 0 : _b[valueName];\r\n            if (!valueIsOptimised || !externalAnimationValue)\r\n                return;\r\n            const removeSyncCheck = value.on(\"change\", (latestValue) => {\r\n                var _a;\r\n                if (externalAnimationValue.get() !== latestValue) {\r\n                    (_a = window.MotionCancelOptimisedAnimation) === null || _a === void 0 ? void 0 : _a.call(window, appearId, valueName);\r\n                    removeSyncCheck();\r\n                }\r\n            });\r\n            return removeSyncCheck;\r\n        };\r\n    }\r\n    const startAnimation = () => {\r\n        readyAnimation.cancel();\r\n        const appearAnimation = animateStyle(element, name, keyframes, options);\r\n        /**\r\n         * Record the time of the first started animation. We call performance.now() once\r\n         * here and once in handoff to ensure we're getting\r\n         * close to a frame-locked time. This keeps all animations in sync.\r\n         */\r\n        if (startFrameTime === undefined) {\r\n            startFrameTime = performance.now();\r\n        }\r\n        appearAnimation.startTime = startFrameTime;\r\n        appearAnimationStore.set(storeId, {\r\n            animation: appearAnimation,\r\n            startTime: startFrameTime,\r\n        });\r\n        if (onReady)\r\n            onReady(appearAnimation);\r\n    };\r\n    elementsWithAppearAnimations.add(id);\r\n    if (readyAnimation.ready) {\r\n        readyAnimation.ready.then(startAnimation).catch(noop);\r\n    }\r\n    else {\r\n        startAnimation();\r\n    }\r\n}\r\n\r\nexport { startOptimizedAppearAnimation };\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}